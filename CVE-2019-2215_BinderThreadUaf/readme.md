Binder is an IPC mechanism used on android, with some BeOS history. This folder contains an exploit for
CVE-2019-2215. 


The quest linux kernel code can be pulled from https://github.com/facebookincubator/oculus-linux-kernel.

Although it is based on MSM 4.4, it is not current. In late September, Google realized that a fix for a bug
that got discovered with syzkaller did not make it to their Wahoo tree. This issue did not have a CVE at the time,
it now does, CVE-2019-2215. It was being exploited in the wild by the NSO group (which Facebook is conicidentally suing right now
for selling weaponized whatsapp exploits to questionable customers).

For MSM 4.4, qualcomm has pulled in the fix from upstream in a timely manner, however Facebook is not current with that tree and the
vulnerability has remained. 

This bug is a fairly trivial UAF. It's possible to use epoll() to wait on events from a binder client.
The driver also allows clients to release the underlying data structure that epoll is waiting from/to. 
In the vulnerable versions of the driver, it is possible to set up an epoll, then release the structure (creating a UAF/dangling pointer),
then release the epoll.  When releaing the epoll it will mangle the lock in the now-released buffer. 


For exploitation, the P0 PoC uses a method that exploits in-flight IOVEC structures (see https://bugs.chromium.org/p/project-zero/issues/detail?id=1942).

This method was previously published by Di Shen at KeenLab (https://www.blackhat.com/docs/eu-16/materials/eu-16-Shen-Rooting-Every-Android-From-Extension-To-Exploitation-wp.pdf)

The in-flight iovecs are flexible -- they can be allocated at variable lengths for matching the size of any Use-After-Free.

Its also possible to use blocking and other features on pipes and sockets to modify state in a controlled manner. Smashing data in the iovec
can be used for arbitrary reads as well as arbitrary writes. 


In the P0 PoC, the current task's 'task_struct' happens to lie at the end of the binder_thread. The exploit uses the UAF corruption to first read this out,
and then modifies that to update the address space limits for the current process. 

The way the UAF corruption works with epoll also lends well for exploitation. When epoll's reference to the thread is released, it will leave behind
a self-referntial pointer. This can be used to create a write into the iovec to update the in-flight structure with arbitrary pointers. 

For this exploit the flow for the corruption is to:

- Create the UAF condition
- Trigger the corruption, leaving behind the self referencing pointer in the IOVEC
- Write an arbitrary destination (in this case the TTBR1 page table entry)
- Write an 8-byte value (rwx/rwx permissions to kernel physical memory)

This lets every linux process have rwx/rwx memory access to kernel memory.

The version of the binder driver in the quest kernel had a further complication as well. Without a transaction ready to read, the poll will happen on a 'binder_proc' structure,
and not a 'binder_thread'. Theres no BINDER_PROC_EXIT, as there is with BINDER_THREAD_EXIT. The exploit runs some code in force_thread() to set up the binder thread to poll
on the correct data structure. 


