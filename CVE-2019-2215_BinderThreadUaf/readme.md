Binder is an IPC mechanism used on android, with some BeOS history. This folder contains an exploit for
CVE-2019-2215. 


The quest linux kernel code can be pulled from https://github.com/facebookincubator/oculus-linux-kernel.

Although this tree is based on MSM 4.4, it is not current. 

In late September, Google realized that a fix for a bug that got discovered with syzkaller did not make it to their Wahoo tree. This issue did not have a CVE at the time it now does: CVE-2019-2215. It's suspected that this was being exploited in the wild by the NSO group. Facebook is coincidentally suing NSO right now regarding that matter.

On MSM 4.4, qualcomm did get the fix from upstream in a timely manner, however since Facebook is not current with that tree this vulnerability and others have remained. 

This bug is a fairly trivial UAF. It's possible to use epoll() to wait on events from a binder client.
The driver also allows clients to release the underlying data structure that epoll is waiting from/to. 
In the vulnerable versions of the driver, it is possible to set up an epoll, then release the structure (creating a UAF/dangling pointer), then release the epoll.  When releaing the epoll it will mangle the lock in the now-released buffer. 


For exploitation, the P0 PoC uses a method that exploits in-flight IOVEC structures (see https://bugs.chromium.org/p/project-zero/issues/detail?id=1942).

This method was previously published by Di Shen at KeenLab (https://www.blackhat.com/docs/eu-16/materials/eu-16-Shen-Rooting-Every-Android-From-Extension-To-Exploitation-wp.pdf)

The in-flight iovecs are flexible -- they can be allocated at variable lengths for matching the size of any Use-After-Free.

Its also possible to use blocking and other features on pipes and sockets to modify state in a controlled manner. Smashing data in the iovec can be used for arbitrary reads as well as arbitrary writes. 


In the P0 PoC, the current task's 'task_struct' happens to lie at the end of the binder_thread, and that exploit reads it out before writing to it. For the Oculus tree, the binder is cold is much older and doesnt contain that member varaible.

The way the UAF corruption works with epoll also lends well for exploitation. When epoll's reference to the thread is released, it will leave behind a self-referntial pointer. This can be used to create a write into the iovec to update the in-flight structure. 

For this exploit the flow for the corruption is to:

- Create the UAF condition
- Trigger the corruption, leaving behind the self referencing pointer in the IOVEC
- Write an arbitrary destination (in this case the TTBR1 page table entry)
- Write an 8-byte value to that destination (rwx/rwx permissions to kernel physical memory)

This lets every linux process have rwx/rwx memory access to kernel memory.

The version of the binder driver in the quest kernel had a further complication as well. Without a transaction ready to read, the poll will happen on a 'binder_proc' structure, and not a 'binder_thread'. Theres no BINDER_PROC_EXIT, as there is with BINDER_THREAD_EXIT. The exploit runs some code in force_thread() to set up the binder thread to poll
on the correct data structure. 


